
---
title: Korean
weight: 10
draft: false
---

{{% author %}}By Oul Han{{% /author %}} 

```{r, message=FALSE}
require(quanteda)
require(KoNLP)
```

## Tokenization

You can use `tokens()` or a morphological analysis tool such as [KoNLP](https://cran.r-project.org/web/packages/KoNLP/index.html) to tokenize Korean texts. The sample corpus contains all 17 transcripts of commencement speeches by Korean presidents from 1948 to 2008. [Click to download the corpus if you want to take a look in the traditional way. ](https://www.dropbox.com/s/1cluzpgjjje9icd/data_corpus_korean-presidential-speeches.RDS?dl=1)

```{r, eval=FALSE}
corp <- download("data_corpus_korean_presidential-speeches")
txt <- tail(texts(corp), 1000)
```

```{r include=FALSE}
# This code is only for website generation
corp <- readRDS("/Users/LG/Dropbox/Public/data_corpus_korean_presidential-speeches.rds")
txt <- tail(texts(corp), 1000)
```

### Dictionary-based boundary detection

`tokens()` can segment Korean texts, but fails to slice off many morphemes that are not necessary for text (content) analysis. However, you may experiment and find that `tokens()` suffices, especially if supplemented with stop words that you tailor for the corpus in question. Thus, `tokens()` is a quick and dirty method for tokenizing Korean without using additional tools and based on the rules defined in the [ICU library](http://site.icu-project.org/home), which is available via the **stringi** package. ICU detects boundaries of words using [a dictionary with frequency information](http://source.icu-project.org/repos/icu/icu/tags/release-58-rc/source/data/brkitr/dictionaries/). As you can see there, ICU doesn't yet support Korean--which explains why the results below are just "kind of okay".

```{r}
icu_toks <- tokens(txt)
head(icu_toks[[10]], 50)
```

### Morphological analysis 

If you want to perform more accurate tokenization, you need to install a morphological analysis tool, and call it from R. [KoNLP](https://cran.r-project.org/web/packages/KoNLP/index.html) is one of the most popular tools for tokenizing Korean texts via **noun extraction**. This function is a slightly more radical form of boundary analysis for dropping unneeded morpheme types that trail behind Korean words without whitespace ("post-positions"). We can use this function from R with **KoNLP**. The package is available on CRAN. 

```{r include=FALSE}
# This code is only for website generation
konlp_toks <- readRDS("/Users/LG/Dropbox/Public/data_list_korean_presidential_speeches.rds")
```

```{r, eval=FALSE}
konlp_toks <- extractNoun(txt)
```

The object `konlp_toks` is a list. Turn it into a `tokens` object that is an innate format of **quanteda**.
```{r}
noun_toks <- as.tokens(konlp_toks) 
```

```{r}
head(noun_toks[[10]], 50)
```

### Refining tokens

Firstly, we can remove numbers with `tokens()`. 
```{r}
head(noun_toks[[7]], 40)
```

```{r}
noun_toks <- tokens(noun_toks, remove_numbers = TRUE)
```

Note that numbers with combined words are not filtered (such as "4반세기" = four half centuries). 
```{r}
head(noun_toks[[7]], 40)
```

Secondly, we can remove Chinese words that occur in older or highly specialized Korean text. In this sample corpus, they tend to appear in brackets after their Korean phonetization. This makes them safe to remove without losing content. We will use regular expressions and the unicode character property ["Han"](http://unicode.org/faq/han_cjk.html) to filter Chinese characters.
```{r}
head(noun_toks[[2]], 40)
```

```{r}
refi_noun_toks <- noun_toks
refi_pure_korean <- tokens_remove(refi_noun_toks, "\\(?\\p{Han}+\\)?", valuetype = "regex") 
```

```{r}
head(refi_pure_korean[[2]], 40)
```

{{% notice info %}}
In this example, R regex doesn't recognize the escape character (such as `\p` or `\(`) so you need to escape the escape (as in `\\p`).
{{% /notice%}}

### Feature selection

The results include a number of monosyllabic morphemes that are almost meaningless for content analysis (such as "한" and "바"). Note that these aren't syllables per se, but words that occupy one character space. Thus, we will extract only words with more than two characters. 

```{r}
refi_pure_korean <- tokens_remove(refi_pure_korean, min_nchar = 2) 
```

```{r}
head(refi_pure_korean[[2]], 40)
```

Stop words act as additional filter, which you can write down as a list then call from quanteda. There is no standard list of stop words for Korean. For now, you should create your own list by identifying and filtering stop words step by step. 


